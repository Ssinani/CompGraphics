import {
	AnimationClip,
	AnimationMixer,
<<<<<<< HEAD
	Euler,
=======
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	Matrix4,
	Quaternion,
	QuaternionKeyframeTrack,
	SkeletonHelper,
<<<<<<< HEAD
	Vector2,
=======
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	Vector3,
	VectorKeyframeTrack
} from 'three';

<<<<<<< HEAD

function retarget( target, source, options = {} ) {

	const pos = new Vector3(),
		quat = new Quaternion(),
		scale = new Vector3(),
		bindBoneMatrix = new Matrix4(),
		relativeMatrix = new Matrix4(),
		globalMatrix = new Matrix4();

	options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;
	options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;
	options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;
	options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
	options.hip = options.hip !== undefined ? options.hip : 'hip';
=======
/**
 * @module SkeletonUtils
 * @three_import import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
 */

function getBoneName( bone, options ) {

	if ( options.getBoneName !== undefined ) {

		return options.getBoneName( bone );

	}

	return options.names[ bone.name ];

}

/**
 * Retargets the skeleton from the given source 3D object to the
 * target 3D object.
 *
 * @param {Object3D} target - The target 3D object.
 * @param {Object3D} source - The source 3D object.
 * @param {module:SkeletonUtils~RetargetOptions} options - The options.
 */
function retarget( target, source, options = {} ) {

	const quat = new Quaternion(),
		scale = new Vector3(),
		relativeMatrix = new Matrix4(),
		globalMatrix = new Matrix4();

	options.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;
	options.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;
	options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
	options.hip = options.hip !== undefined ? options.hip : 'hip';
	options.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new Vector3( 1, 1, 1 );
	options.scale = options.scale !== undefined ? options.scale : 1;
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	options.names = options.names || {};

	const sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),
		bones = target.isObject3D ? target.skeleton.bones : getBones( target );

<<<<<<< HEAD
	let bindBones,
		bone, name, boneTo,
=======
	let bone, name, boneTo,
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
		bonesPosition;

	// reset bones

	if ( target.isObject3D ) {

		target.skeleton.pose();

	} else {

		options.useTargetMatrix = true;
<<<<<<< HEAD
		options.preserveMatrix = false;

	}

	if ( options.preservePosition ) {
=======
		options.preserveBoneMatrix = false;

	}

	if ( options.preserveBonePositions ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		bonesPosition = [];

		for ( let i = 0; i < bones.length; i ++ ) {

			bonesPosition.push( bones[ i ].position.clone() );

		}

	}

<<<<<<< HEAD
	if ( options.preserveMatrix ) {
=======
	if ( options.preserveBoneMatrix ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		// reset matrix

		target.updateMatrixWorld();

		target.matrixWorld.identity();

		// reset children matrix

		for ( let i = 0; i < target.children.length; ++ i ) {

			target.children[ i ].updateMatrixWorld( true );

		}

	}

<<<<<<< HEAD
	if ( options.offsets ) {

		bindBones = [];

		for ( let i = 0; i < bones.length; ++ i ) {

			bone = bones[ i ];
			name = options.names[ bone.name ] || bone.name;

			if ( options.offsets[ name ] ) {

				bone.matrix.multiply( options.offsets[ name ] );

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				bone.updateMatrixWorld();

			}

			bindBones.push( bone.matrixWorld.clone() );

		}

	}

	for ( let i = 0; i < bones.length; ++ i ) {

		bone = bones[ i ];
		name = options.names[ bone.name ] || bone.name;
=======
	for ( let i = 0; i < bones.length; ++ i ) {

		bone = bones[ i ];
		name = getBoneName( bone, options );
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		boneTo = getBoneByName( name, sourceBones );

		globalMatrix.copy( bone.matrixWorld );

		if ( boneTo ) {

			boneTo.updateMatrixWorld();

			if ( options.useTargetMatrix ) {

				relativeMatrix.copy( boneTo.matrixWorld );

			} else {

				relativeMatrix.copy( target.matrixWorld ).invert();
				relativeMatrix.multiply( boneTo.matrixWorld );

			}

			// ignore scale to extract rotation

			scale.setFromMatrixScale( relativeMatrix );
			relativeMatrix.scale( scale.set( 1 / scale.x, 1 / scale.y, 1 / scale.z ) );

			// apply to global matrix

			globalMatrix.makeRotationFromQuaternion( quat.setFromRotationMatrix( relativeMatrix ) );

			if ( target.isObject3D ) {

<<<<<<< HEAD
				const boneIndex = bones.indexOf( bone ),
					wBindMatrix = bindBones ? bindBones[ boneIndex ] : bindBoneMatrix.copy( target.skeleton.boneInverses[ boneIndex ] ).invert();

				globalMatrix.multiply( wBindMatrix );
=======
				if ( options.localOffsets ) {

					if ( options.localOffsets[ bone.name ] ) {

						globalMatrix.multiply( options.localOffsets[ bone.name ] );

					}

				}
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

			}

			globalMatrix.copyPosition( relativeMatrix );

		}

<<<<<<< HEAD
		if ( bone.parent && bone.parent.isBone ) {
=======
		if ( name === options.hip ) {

			globalMatrix.elements[ 12 ] *= options.scale * options.hipInfluence.x;
			globalMatrix.elements[ 13 ] *= options.scale * options.hipInfluence.y;
			globalMatrix.elements[ 14 ] *= options.scale * options.hipInfluence.z;

			if ( options.hipPosition !== undefined ) {

				globalMatrix.elements[ 12 ] += options.hipPosition.x * options.scale;
				globalMatrix.elements[ 13 ] += options.hipPosition.y * options.scale;
				globalMatrix.elements[ 14 ] += options.hipPosition.z * options.scale;

			}

		}

		if ( bone.parent ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

			bone.matrix.copy( bone.parent.matrixWorld ).invert();
			bone.matrix.multiply( globalMatrix );

		} else {

			bone.matrix.copy( globalMatrix );

		}

<<<<<<< HEAD
		if ( options.preserveHipPosition && name === options.hip ) {

			bone.matrix.setPosition( pos.set( 0, bone.position.y, 0 ) );

		}

=======
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
		bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

		bone.updateMatrixWorld();

	}

<<<<<<< HEAD
	if ( options.preservePosition ) {
=======
	if ( options.preserveBonePositions ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		for ( let i = 0; i < bones.length; ++ i ) {

			bone = bones[ i ];
<<<<<<< HEAD
			name = options.names[ bone.name ] || bone.name;
=======
			name = getBoneName( bone, options ) || bone.name;
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

			if ( name !== options.hip ) {

				bone.position.copy( bonesPosition[ i ] );

			}

		}

	}

<<<<<<< HEAD
	if ( options.preserveMatrix ) {
=======
	if ( options.preserveBoneMatrix ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		// restore matrix

		target.updateMatrixWorld( true );

	}

}

<<<<<<< HEAD
function retargetClip( target, source, clip, options = {} ) {

	options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;
	options.fps = options.fps !== undefined ? options.fps : 30;
=======
/**
 * Retargets the animation clip of the source object to the
 * target 3D object.
 *
 * @param {Object3D} target - The target 3D object.
 * @param {Object3D} source - The source 3D object.
 * @param {AnimationClip} clip - The animation clip.
 * @param {module:SkeletonUtils~RetargetOptions} options - The options.
 * @return {AnimationClip} The retargeted animation clip.
 */
function retargetClip( target, source, clip, options = {} ) {

	options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;

	// Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.
	options.fps = options.fps !== undefined ? options.fps : ( Math.max( ...clip.tracks.map( track => track.times.length ) ) / clip.duration );
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	options.names = options.names || [];

	if ( ! source.isObject3D ) {

		source = getHelperFromSkeleton( source );

	}

	const numFrames = Math.round( clip.duration * ( options.fps / 1000 ) * 1000 ),
<<<<<<< HEAD
		delta = 1 / options.fps,
=======
		delta = clip.duration / ( numFrames - 1 ),
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
		convertedTracks = [],
		mixer = new AnimationMixer( source ),
		bones = getBones( target.skeleton ),
		boneDatas = [];
<<<<<<< HEAD
=======

>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	let positionOffset,
		bone, boneTo, boneData,
		name;

	mixer.clipAction( clip ).play();
<<<<<<< HEAD
	mixer.update( 0 );

	source.updateMatrixWorld();

	for ( let i = 0; i < numFrames; ++ i ) {

		const time = i * delta;
=======

	// trim

	let start = 0, end = numFrames;

	if ( options.trim !== undefined ) {

		start = Math.round( options.trim[ 0 ] * options.fps );
		end = Math.min( Math.round( options.trim[ 1 ] * options.fps ), numFrames ) - start;

		mixer.update( options.trim[ 0 ] );

	} else {

		mixer.update( 0 );

	}

	source.updateMatrixWorld();

	//

	for ( let frame = 0; frame < end; ++ frame ) {

		const time = frame * delta;
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		retarget( target, source, options );

		for ( let j = 0; j < bones.length; ++ j ) {

<<<<<<< HEAD
			name = options.names[ bones[ j ].name ] || bones[ j ].name;

=======
			bone = bones[ j ];
			name = getBoneName( bone, options ) || bone.name;
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
			boneTo = getBoneByName( name, source.skeleton );

			if ( boneTo ) {

<<<<<<< HEAD
				bone = bones[ j ];
=======
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
				boneData = boneDatas[ j ] = boneDatas[ j ] || { bone: bone };

				if ( options.hip === name ) {

					if ( ! boneData.pos ) {

						boneData.pos = {
<<<<<<< HEAD
							times: new Float32Array( numFrames + 1 ),
							values: new Float32Array( ( numFrames + 1 ) * 3 )
=======
							times: new Float32Array( end ),
							values: new Float32Array( end * 3 )
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
						};

					}

					if ( options.useFirstFramePosition ) {

<<<<<<< HEAD
						if ( i === 0 ) {
=======
						if ( frame === 0 ) {
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

							positionOffset = bone.position.clone();

						}

						bone.position.sub( positionOffset );

					}

<<<<<<< HEAD
					boneData.pos.times[ i ] = time;

					bone.position.toArray( boneData.pos.values, i * 3 );
=======
					boneData.pos.times[ frame ] = time;

					bone.position.toArray( boneData.pos.values, frame * 3 );
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

				}

				if ( ! boneData.quat ) {

<<<<<<< HEAD
					// `numFrames + 1` accomodate final keyframe
					boneData.quat = {
						times: new Float32Array( numFrames + 1 ),
						values: new Float32Array( ( numFrames + 1 ) * 4 )
=======
					boneData.quat = {
						times: new Float32Array( end ),
						values: new Float32Array( end * 4 )
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
					};

				}

<<<<<<< HEAD
				boneData.quat.times[ i ] = time;

				bone.quaternion.toArray( boneData.quat.values, i * 4 );
=======
				boneData.quat.times[ frame ] = time;

				bone.quaternion.toArray( boneData.quat.values, frame * 4 );
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

			}

		}

<<<<<<< HEAD
		// check for final keyframe
		if ( i === numFrames - 1 ) {

			mixer.update( Math.max( clip.duration - mixer.time, 0 ) );
=======
		if ( frame === end - 2 ) {

			// last mixer update before final loop iteration
			// make sure we do not go over or equal to clip duration
			mixer.update( delta - 0.0000001 );
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

		} else {

			mixer.update( delta );

		}

		source.updateMatrixWorld();

	}

<<<<<<< HEAD
	retarget( target, source, options );

	// add boneData at final keyframe
	for ( let j = 0; j < boneDatas.length; ++ j ) {

		boneData = boneDatas[ j ];

		if ( boneData ) {

			if ( boneData.pos ) {

				boneData.pos.times[ numFrames ] = clip.duration;

				bone.position.toArray( boneData.pos.values, numFrames * 3 );

			}

			if ( boneData.quat ) {

				boneData.quat.times[ numFrames ] = clip.duration;

				bone.position.toArray( boneData.quat.values, numFrames * 4 );

			}

		}

	}


=======
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	for ( let i = 0; i < boneDatas.length; ++ i ) {

		boneData = boneDatas[ i ];

		if ( boneData ) {

			if ( boneData.pos ) {

				convertedTracks.push( new VectorKeyframeTrack(
					'.bones[' + boneData.bone.name + '].position',
					boneData.pos.times,
					boneData.pos.values
				) );

			}

			convertedTracks.push( new QuaternionKeyframeTrack(
				'.bones[' + boneData.bone.name + '].quaternion',
				boneData.quat.times,
				boneData.quat.values
			) );

		}

	}

	mixer.uncacheAction( clip );

	return new AnimationClip( clip.name, - 1, convertedTracks );

}

<<<<<<< HEAD
function getHelperFromSkeleton( skeleton ) {

	const source = new SkeletonHelper( skeleton.bones[ 0 ] );
	source.skeleton = skeleton;

	return source;

}

function getSkeletonOffsets( target, source, options = {} ) {

	const targetParentPos = new Vector3(),
		targetPos = new Vector3(),
		sourceParentPos = new Vector3(),
		sourcePos = new Vector3(),
		targetDir = new Vector2(),
		sourceDir = new Vector2();

	options.hip = options.hip !== undefined ? options.hip : 'hip';
	options.names = options.names || {};

	if ( ! source.isObject3D ) {

		source = getHelperFromSkeleton( source );

	}

	const nameKeys = Object.keys( options.names ),
		nameValues = Object.values( options.names ),
		sourceBones = source.isObject3D ? source.skeleton.bones : getBones( source ),
		bones = target.isObject3D ? target.skeleton.bones : getBones( target ),
		offsets = [];

	let bone, boneTo,
		name, i;

	target.skeleton.pose();

	for ( i = 0; i < bones.length; ++ i ) {

		bone = bones[ i ];
		name = options.names[ bone.name ] || bone.name;

		boneTo = getBoneByName( name, sourceBones );

		if ( boneTo && name !== options.hip ) {

			const boneParent = getNearestBone( bone.parent, nameKeys ),
				boneToParent = getNearestBone( boneTo.parent, nameValues );

			boneParent.updateMatrixWorld();
			boneToParent.updateMatrixWorld();

			targetParentPos.setFromMatrixPosition( boneParent.matrixWorld );
			targetPos.setFromMatrixPosition( bone.matrixWorld );

			sourceParentPos.setFromMatrixPosition( boneToParent.matrixWorld );
			sourcePos.setFromMatrixPosition( boneTo.matrixWorld );

			targetDir.subVectors(
				new Vector2( targetPos.x, targetPos.y ),
				new Vector2( targetParentPos.x, targetParentPos.y )
			).normalize();

			sourceDir.subVectors(
				new Vector2( sourcePos.x, sourcePos.y ),
				new Vector2( sourceParentPos.x, sourceParentPos.y )
			).normalize();

			const laterialAngle = targetDir.angle() - sourceDir.angle();

			const offset = new Matrix4().makeRotationFromEuler(
				new Euler(
					0,
					0,
					laterialAngle
				)
			);

			bone.matrix.multiply( offset );

			bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			bone.updateMatrixWorld();

			offsets[ name ] = offset;

		}

	}

	return offsets;

}

function renameBones( skeleton, names ) {

	const bones = getBones( skeleton );

	for ( let i = 0; i < bones.length; ++ i ) {

		const bone = bones[ i ];

		if ( names[ bone.name ] ) {

			bone.name = names[ bone.name ];

		}

	}

	return this;

}

function getBones( skeleton ) {

	return Array.isArray( skeleton ) ? skeleton : skeleton.bones;

}

function getBoneByName( name, skeleton ) {

	for ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {

		if ( name === bones[ i ].name )

			return bones[ i ];

	}

}

function getNearestBone( bone, names ) {

	while ( bone.isBone ) {

		if ( names.indexOf( bone.name ) !== - 1 ) {

			return bone;

		}

		bone = bone.parent;

	}

}

function findBoneTrackData( name, tracks ) {

	const regexp = /\[(.*)\]\.(.*)/,
		result = { name: name };

	for ( let i = 0; i < tracks.length; ++ i ) {

		// 1 is track name
		// 2 is track type
		const trackData = regexp.exec( tracks[ i ].name );

		if ( trackData && name === trackData[ 1 ] ) {

			result[ trackData[ 2 ] ] = i;

		}

	}

	return result;

}

function getEqualsBonesNames( skeleton, targetSkeleton ) {

	const sourceBones = getBones( skeleton ),
		targetBones = getBones( targetSkeleton ),
		bones = [];

	search : for ( let i = 0; i < sourceBones.length; i ++ ) {

		const boneName = sourceBones[ i ].name;

		for ( let j = 0; j < targetBones.length; j ++ ) {

			if ( boneName === targetBones[ j ].name ) {

				bones.push( boneName );

				continue search;

			}

		}

	}

	return bones;

}

=======
/**
 * Clones the given 3D object and its descendants, ensuring that any `SkinnedMesh` instances are
 * correctly associated with their bones. Bones are also cloned, and must be descendants of the
 * object passed to this method. Other data, like geometries and materials, are reused by reference.
 *
 * @param {Object3D} source - The 3D object to clone.
 * @return {Object3D} The cloned 3D object.
 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
function clone( source ) {

	const sourceLookup = new Map();
	const cloneLookup = new Map();

	const clone = source.clone();

	parallelTraverse( source, clone, function ( sourceNode, clonedNode ) {

		sourceLookup.set( clonedNode, sourceNode );
		cloneLookup.set( sourceNode, clonedNode );

	} );

	clone.traverse( function ( node ) {

		if ( ! node.isSkinnedMesh ) return;

		const clonedMesh = node;
		const sourceMesh = sourceLookup.get( node );
		const sourceBones = sourceMesh.skeleton.bones;

		clonedMesh.skeleton = sourceMesh.skeleton.clone();
		clonedMesh.bindMatrix.copy( sourceMesh.bindMatrix );

		clonedMesh.skeleton.bones = sourceBones.map( function ( bone ) {

			return cloneLookup.get( bone );

		} );

		clonedMesh.bind( clonedMesh.skeleton, clonedMesh.bindMatrix );

	} );

	return clone;

}

<<<<<<< HEAD


=======
// internal helper

function getBoneByName( name, skeleton ) {

	for ( let i = 0, bones = getBones( skeleton ); i < bones.length; i ++ ) {

		if ( name === bones[ i ].name )

			return bones[ i ];

	}

}

function getBones( skeleton ) {

	return Array.isArray( skeleton ) ? skeleton : skeleton.bones;

}


function getHelperFromSkeleton( skeleton ) {

	const source = new SkeletonHelper( skeleton.bones[ 0 ] );
	source.skeleton = skeleton;

	return source;

}
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

function parallelTraverse( a, b, callback ) {

	callback( a, b );

	for ( let i = 0; i < a.children.length; i ++ ) {

		parallelTraverse( a.children[ i ], b.children[ i ], callback );

	}

}

<<<<<<< HEAD
export {
	retarget,
	retargetClip,
	getHelperFromSkeleton,
	getSkeletonOffsets,
	renameBones,
	getBones,
	getBoneByName,
	getNearestBone,
	findBoneTrackData,
	getEqualsBonesNames,
=======
/**
 * Retarget options of `SkeletonUtils`.
 *
 * @typedef {Object} module:SkeletonUtils~RetargetOptions
 * @property {boolean} [useFirstFramePosition=false] - Whether to use the position of the first frame or not.
 * @property {number} [fps] - The FPS of the clip.
 * @property {Object<string,string>} [names] - A dictionary for mapping target to source bone names.
 * @property {function(string):string} [getBoneName] - A function for mapping bone names. Alternative to `names`.
 * @property {Array<number>} [trim] - Whether to trim the clip or not. If set the array should hold two values for the start and end.
 * @property {boolean} [preserveBoneMatrix=true] - Whether to preserve bone matrices or not.
 * @property {boolean} [preserveBonePositions=true] - Whether to preserve bone positions or not.
 * @property {boolean} [useTargetMatrix=false] - Whether to use the target matrix or not.
 * @property {string} [hip='hip'] - The name of the source's hip bone.
 * @property {Vector3} [hipInfluence=(1,1,1)] - The hip influence.
 * @property {number} [scale=1] - The scale.
 **/

export {
	retarget,
	retargetClip,
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	clone,
};
