import {
	Vector3
} from 'three';

<<<<<<< HEAD
const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();

const EPS = 1e-10;

class Capsule {

	constructor( start = new Vector3( 0, 0, 0 ), end = new Vector3( 0, 1, 0 ), radius = 1 ) {

		this.start = start;
		this.end = end;
=======
/**
 * A capsule is essentially a cylinder with hemispherical caps at both ends.
 * It can be thought of as a swept sphere, where a sphere is moved along a line segment.
 *
 * Capsules are often used as bounding volumes (next to AABBs and bounding spheres).
 *
 * @three_import import { Capsule } from 'three/addons/math/Capsule.js';
 */
class Capsule {

	/**
	 * Constructs a new capsule.
	 *
	 * @param {Vector3} [start] - The start vector.
	 * @param {Vector3} [end] - The end vector.
	 * @param {number} [radius=1] - The capsule's radius.
	 */
	constructor( start = new Vector3( 0, 0, 0 ), end = new Vector3( 0, 1, 0 ), radius = 1 ) {

		/**
		 * The start vector.
		 *
		 * @type {Vector3}
		 */
		this.start = start;

		/**
		 * The end vector.
		 *
		 * @type {Vector3}
		 */
		this.end = end;

		/**
		 * The capsule's radius.
		 *
		 * @type {number}
		 * @default 1
		 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
		this.radius = radius;

	}

<<<<<<< HEAD
	clone() {

		return new Capsule( this.start.clone(), this.end.clone(), this.radius );

	}

=======
	/**
	 * Returns a new capsule with copied values from this instance.
	 *
	 * @return {Capsule} A clone of this instance.
	 */
	clone() {

		return new this.constructor().copy( this );

	}

	/**
	 * Sets the capsule components to the given values.
	 * Please note that this method only copies the values from the given objects.
	 *
	 * @param {Vector3} start - The start vector.
	 * @param {Vector3} end - The end vector
	 * @param {number} radius - The capsule's radius.
	 * @return {Capsule} A reference to this capsule.
	 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	set( start, end, radius ) {

		this.start.copy( start );
		this.end.copy( end );
		this.radius = radius;

<<<<<<< HEAD
	}

=======
		return this;

	}

	/**
	 * Copies the values of the given capsule to this instance.
	 *
	 * @param {Capsule} capsule - The capsule to copy.
	 * @return {Capsule} A reference to this capsule.
	 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	copy( capsule ) {

		this.start.copy( capsule.start );
		this.end.copy( capsule.end );
		this.radius = capsule.radius;

<<<<<<< HEAD
	}

=======
		return this;

	}

	/**
	 * Returns the center point of this capsule.
	 *
	 * @param {Vector3} target - The target vector that is used to store the method's result.
	 * @return {Vector3} The center point.
	 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	getCenter( target ) {

		return target.copy( this.end ).add( this.start ).multiplyScalar( 0.5 );

	}

<<<<<<< HEAD
=======
	/**
	 * Adds the given offset to this capsule, effectively moving it in 3D space.
	 *
	 * @param {Vector3} v - The offset that should be used to translate the capsule.
	 * @return {Capsule} A reference to this capsule.
	 */
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
	translate( v ) {

		this.start.add( v );
		this.end.add( v );

<<<<<<< HEAD
	}

	checkAABBAxis( p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius ) {

		return (
			( minx - p1x < radius || minx - p2x < radius ) &&
			( p1x - maxx < radius || p2x - maxx < radius ) &&
			( miny - p1y < radius || miny - p2y < radius ) &&
			( p1y - maxy < radius || p2y - maxy < radius )
		);

	}

	intersectsBox( box ) {

		return (
			this.checkAABBAxis(
				this.start.x, this.start.y, this.end.x, this.end.y,
				box.min.x, box.max.x, box.min.y, box.max.y,
				this.radius ) &&
			this.checkAABBAxis(
				this.start.x, this.start.z, this.end.x, this.end.z,
				box.min.x, box.max.x, box.min.z, box.max.z,
				this.radius ) &&
			this.checkAABBAxis(
=======
		return this;

	}

	/**
	 * Returns `true` if the given bounding box intersects with this capsule.
	 *
	 * @param {Box3} box - The bounding box to test.
	 * @return {boolean} Whether the given bounding box intersects with this capsule.
	 */
	intersectsBox( box ) {

		return (
			checkAABBAxis(
				this.start.x, this.start.y, this.end.x, this.end.y,
				box.min.x, box.max.x, box.min.y, box.max.y,
				this.radius ) &&
			checkAABBAxis(
				this.start.x, this.start.z, this.end.x, this.end.z,
				box.min.x, box.max.x, box.min.z, box.max.z,
				this.radius ) &&
			checkAABBAxis(
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46
				this.start.y, this.start.z, this.end.y, this.end.z,
				box.min.y, box.max.y, box.min.z, box.max.z,
				this.radius )
		);

	}

<<<<<<< HEAD
	lineLineMinimumPoints( line1, line2 ) {

		const r = _v1.copy( line1.end ).sub( line1.start );
		const s = _v2.copy( line2.end ).sub( line2.start );
		const w = _v3.copy( line2.start ).sub( line1.start );

		const a = r.dot( s ),
			b = r.dot( r ),
			c = s.dot( s ),
			d = s.dot( w ),
			e = r.dot( w );

		let t1, t2;
		const divisor = b * c - a * a;

		if ( Math.abs( divisor ) < EPS ) {

			const d1 = - d / c;
			const d2 = ( a - d ) / c;

			if ( Math.abs( d1 - 0.5 ) < Math.abs( d2 - 0.5 ) ) {

				t1 = 0;
				t2 = d1;

			} else {

				t1 = 1;
				t2 = d2;

			}

		} else {

			t1 = ( d * a + e * c ) / divisor;
			t2 = ( t1 * a - d ) / c;

		}

		t2 = Math.max( 0, Math.min( 1, t2 ) );
		t1 = Math.max( 0, Math.min( 1, t1 ) );

		const point1 = r.multiplyScalar( t1 ).add( line1.start );
		const point2 = s.multiplyScalar( t2 ).add( line2.start );

		return [ point1, point2 ];

	}
=======
}

function checkAABBAxis( p1x, p1y, p2x, p2y, minx, maxx, miny, maxy, radius ) {

	return (
		( minx - p1x < radius || minx - p2x < radius ) &&
		( p1x - maxx < radius || p2x - maxx < radius ) &&
		( miny - p1y < radius || miny - p2y < radius ) &&
		( p1y - maxy < radius || p2y - maxy < radius )
	);
>>>>>>> ec4a72bf778c99f3fba07e5595dd4831f9280f46

}

export { Capsule };
